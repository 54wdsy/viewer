<!doctype html>
<html lang=en >
<head>
<title>JSON - Import - View</title>
<meta charset=utf-8 >
<meta name=viewport content=width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0 >
</head>
<body>
<script src=http://mrdoob.github.io/three.js/build/three.min.js ></script>
<script src=http://mrdoob.github.io/three.js/examples/js/controls/TrackballControls.js ></script>
<script src=http://mrdoob.github.io/three.js/examples/js/libs/stats.min.js ></script>
<script>
	var info, stats, renderer, scene, camera, controls;
	var geometry, material, mesh;

	init();
	animate();

	function init() {

		document.body.style.cssText = 'font: 600 12pt monospace; margin: 0; overflow: hidden' ;

		info = document.body.appendChild( document.createElement( 'div' ) );

		info.style.cssText = 'left: 20px; position: absolute; top: 0px; width: 100% ';
		info.innerHTML = '<h1>' + document.title + '</h1>' +
			'<p><input type=file id=inpFile ></p>' +
			'<div id=msg></div>';

		inpFile.onchange = function() { handleJSON ( this ) };

		stats = new Stats();
		stats.domElement.style.cssText = 'position: absolute; right: 0; top: 0; zIndex: 100; ';
		document.body.appendChild( stats.domElement );

		renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true, clearColor: 0xffffff }  );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.set( 100, 100, 100 );
		controls = new THREE.TrackballControls( camera, renderer.domElement );

// axes - just to show soemthing
		scene.add( new THREE.ArrowHelper( v(1, 0, 0), v(0, 0, 0), 30, 0xcc0000) );
		scene.add( new THREE.ArrowHelper( v(0, 1, 0), v(0, 0, 0), 30, 0x00cc00) );
		scene.add( new THREE.ArrowHelper( v(0, 0, 1), v(0, 0, 0), 30, 0x0000cc) );

	}

	function handleJSON ( that ) {
		if ( that.files && that.files[0]){

			var loader = new THREE.ObjectLoader();
			var reader = new FileReader();
			reader.onload = function ( event ) {  
				data = JSON.parse( event.target.result );
console.log( 'loaded' );
				if ( data.metadata === undefined ) { // 2.0
					data.metadata = { type: 'Geometry' };
				}
				if ( data.metadata.type === undefined ) { // 3.0
					data.metadata.type = 'Geometry';
				}
				if ( data.metadata.version === undefined ) {
					data.metadata.version = data.metadata.formatVersion;
				}
console.log( 'metadata read' );
				if ( data.metadata.type.toLowerCase() === 'geometry' ) {
					var loader = new THREE.JSONLoader();
					var result = loader.parse( data );
					var geometry = result.geometry;

					var material;
					if ( result.materials !== undefined ) {
						if ( result.materials.length > 1 ) {
							material = new THREE.MeshFaceMaterial( result.materials );
						} else {
							material = result.materials[ 0 ];
						}
					} else {
						material = new THREE.MeshNormalMaterial( { wireframe: true } );
					}
					mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );
				} else if ( data.metadata.type.toLowerCase() === 'object' ) {
					var loader = new THREE.ObjectLoader();
					var result = loader.parse( data );
console.log( 'parsed' );
					if ( result instanceof THREE.Scene ) {
						scene.add( result );
					} else {
						scene.add( result );
						var l = scene.children.length - 1;
						msg.innerHTML = 'Author ' + scene.children[ l ].userData.author + '<br>' +
							'Date ' + scene.children[ l ].userData.date;
					}
				} else if ( data.metadata.type.toLowerCase() === 'scene' ) {
					// DEPRECATED
					var loader = new THREE.SceneLoader();
					loader.parse( data, function ( result ) {
						scene = result.scene;
					}, '' );
				}
			}
			reader.readAsText( that.files[0] );
		}
	}

	function v(  x, y, z){ return new THREE.Vector3( x, y, z ); }

	function animate() {
		requestAnimationFrame( animate );
		renderer.render( scene, camera );
		controls.update();
		stats.update();
	}
</script>
</body>
</html>